\documentclass[pdf]{beamer}
\newcommand\REV{v0.0.1}
% Berlin Berkeley Warsaw
\newcommand\z[1]{\texttt{#1}}
\usepackage{listings}
\usepackage{xeCJK}
\newcommand\identifier[1]{{\color{green!70!black}\z{#1}}}
\newcommand\keyword[1]{{\color{blue}\z{#1}}}
\newcommand\blocked[1]{{\color{red}\z{#1}}}
\lstset{
	language=Go,
	basicstyle=\ttfamily,
	keywordstyle=\color{blue}\ttfamily\bfseries,
	identifierstyle=\color{green!70!black},
	commentstyle=\ttfamily\color{gray},
	stringstyle=\ttfamily\color{red},
	showstringspaces=true
}
\mode<presentation>{\usetheme{Berlin}\useoutertheme{infolines}\useinnertheme{rounded}}
\title{A Whirlwind Tour of Go}
\subtitle{Just the Cool Parts}
\author{Steve Willoughby}
\date{10-Apr-2024\\{\tiny\REV}}
\begin{document}
\begin{frame}
	\titlepage
	\begin{center}
	\includegraphics[height=.25\textheight]{go-logo}
	\includegraphics[height=.25\textheight]{gopher}
	\end{center}
\end{frame}
\section[Overview]{Overview}
\subsection{What Are We Doing Here?}
\begin{frame}{The Point}
	\begin{itemize}
		\item ``What \emph{is} Go?''
		\item ``What is it actually good for?''
		\item ``Why should I care?''
	\end{itemize}
\end{frame}
\subsection{Motivation for Go}
\begin{frame}{30 Seconds of History}
	\begin{itemize}
		\item Designed by Rob Pike, Ken Thompson, and Robert Griesemer.
		\item Includes direct experience with C from day 1 to now.
			\pause
		\item ``If we were to design C today, knowing what we know now, on today's technology\dots''
			\pause
			\begin{itemize}
		\item $\therefore$ Go's syntax is very much like C's
		\item \dots\ but cleaned up and streamlined a bit.
			\end{itemize}
		\pause
	\item Dreamed up while waiting on a 45-minute C$^{++}$ compile
		\pause
			\begin{itemize}
				\item Fast compilation
				\item Native binary compiler with low overhead
				\item Strong static typing
				\item Extraordinarily spartan
			\end{itemize}
	\end{itemize}
\end{frame}
\subsection{The Basics of Go}
\begin{frame}[fragile]{Go Syntax}
	\begin{itemize}
		\item Type declarations \emph{follow} identifier names
\begin{lstlisting}
var x int
var UserName string

func AddNumbers(x, y int) int { ... }
func DivideNumbers(x, y int) (int, error) { ... }

type Shape struct {
   X     int
   Y     int
   Color ColorCode
}
\end{lstlisting}
	\end{itemize}
\end{frame}
\begin{frame}{Program Structure}
	\begin{itemize}
		\item Basic unit is a \emph{package} (namespace boundary).\pause
		\item Multiple source files in a package, in the same directory tree.\pause
		\item Every program must have a \identifier{main} package.
		\item The \identifier{main} package has a \identifier{main} function.\pause
		\item Import packages into the program using the \keyword{import} statement.
		\item Always prefix identifiers from imported packages with their package name.\pause
		\item Identifiers can be \emph{public} or \emph{private} w/r/t package boundaries.\pause
			\begin{itemize}
				\item Identifier names starting with an uppercase letter are public.
				\item All others are private.
			\end{itemize}
	\end{itemize}
\end{frame}
\begin{frame}[fragile]{Hello, World}
\begin{lstlisting}
/* Standard-issue "Hello, World" program in Go */

package main

import "fmt"

func main() {
     fmt.Println("Hello, 世界")
}
\end{lstlisting}
\end{frame}
\subsection{The Go Ecosystem}
\begin{frame}{The Playground}
	\begin{itemize}
		\item Interactive playground to immediately try something in Go.
		\item \z{https://go.dev/play/}
	\end{itemize}
	\begin{center}
		\includegraphics[width=\textwidth]{playground}
	\end{center}
\end{frame}
\begin{frame}[fragile]{Importing Third-Party Packages}
	\begin{itemize}
		\item Standard library package names are simple names:
			\begin{lstlisting}
import "fmt"
import "encoding/json"
import "flag"
import "math"
\end{lstlisting}
\pause
		\item Getting packages from public repositories:
\begin{lstlisting}
import "github.com/MadScienceZone/go-gma/v5/dice"
\end{lstlisting}
	\end{itemize}
	\vfill
	\strut
\end{frame}
\begin{frame}{Automatic API Documentation}
\begin{itemize}
\item\z{https://pkg.go.dev/}\emph{repository-url}
\end{itemize}
	\begin{center}
		\includegraphics[width=\textwidth]{docsite}
	\end{center}
\end{frame}

\begin{frame}[fragile]{``Factored'' Notation}
\begin{lstlisting}
import "fmt"
import "encoding/json"
import "flag"
import "math"
\end{lstlisting}
\pause
\begin{lstlisting}
import (
   "fmt"
   "encoding/json"
   "flag"
   "math"
)
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{``Factored'' Notation}
\begin{lstlisting}
var initialized bool
var userNames   []string
var Greeting    string   = "Hello"
var TheAnswer            = 42
\end{lstlisting}
\begin{lstlisting}
var (
    initialized bool
    userNames   []string
    Greeting    string   = "Hello"
    TheAnswer            = 42
)
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{``Factored'' Notation}
\begin{lstlisting}
const initialized = false
const Greeting    = "Hello"
const TheAnswer   byte = 42
\end{lstlisting}
\begin{lstlisting}
const (
    initialized      = false
    Greeting         = "Hello"
    TheAnswer   byte = 42
)
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{``Factored'' Notation and iota}
\begin{onlyenv}<1->
\begin{lstlisting}
type MessageType byte
const (
    ServerCommand MessageType = 0
    ServerReply   MessageType = 1
    ServerError   MessageType = 2
    UrgentMessage MessageType = 3
)
\end{lstlisting}
\end{onlyenv}
\vfill\strut
\begin{onlyenv}<2>
\begin{lstlisting}
type MessageType byte
const (
    ServerCommand MessageType = iota
    ServerReply   MessageType = iota
    ServerError   MessageType = iota
    UrgentMessage MessageType = iota
)
\end{lstlisting}
\end{onlyenv}
\begin{onlyenv}<3>
\begin{lstlisting}
type MessageType byte
const (
    ServerCommand MessageType = iota
    ServerReply   
    ServerError   
    UrgentMessage 
)
\end{lstlisting}
\end{onlyenv}
\end{frame}
\begin{frame}[fragile]{``Factored'' Notation and iota Expressions}
\begin{lstlisting}
type MessageType byte
const (
    ServerCommand MessageType = 0x01
    ServerReply   MessageType = 0x02
    ServerError   MessageType = 0x04
    UrgentMessage MessageType = 0x08
)
\end{lstlisting}
\vfill\strut
\begin{lstlisting}
type MessageType byte
const (
    ServerCommand MessageType = 1 << iota
    ServerReply   
    ServerError   
    UrgentMessage 
)
\end{lstlisting}
\end{frame}
\section[Concurrency]{Concurrency}
\subsection{Thread-Safe Memory Access}
\begin{frame}[fragile]{Global ID Generation (Na\"\i ve)}
\begin{lstlisting}
type GameState struct {
    NextMessageID int
}
\end{lstlisting}
\pause
\begin{lstlisting}
var gameServer GameState

gameServer.NextMessageID++
client.ID = gameServer.NextMessageID
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Global ID Generation (Mutex)}
\begin{onlyenv}<1>
\begin{lstlisting}
type GameState struct {
    NextMessageID int
    Lock          sync.Mutex
}
\end{lstlisting}
\end{onlyenv}
\begin{onlyenv}<2->
\begin{lstlisting}
type GameState struct {
    NextMessageID int
    Lock          sync.RWMutex
}
\end{lstlisting}
\end{onlyenv}
\begin{onlyenv}<3-4>
\begin{lstlisting}
func (state *GameState) GetNextID() int {
    state.Lock.Lock()
    state.NextMessageID++
    nextID := state.MessageID
    state.Lock.Unlock()
    return nextID
}
\end{lstlisting}
\end{onlyenv}
\begin{onlyenv}<5>
\begin{lstlisting}
func (state *GameState) GetNextID() int {
    state.Lock.Lock()
    defer state.Lock.Unlock()

    state.NextMessageID++
    return state.NextMessageID
}
\end{lstlisting}
\end{onlyenv}
\begin{onlyenv}<4->
\begin{lstlisting}
client.ID = gameServer.GetNextID()
\end{lstlisting}
\end{onlyenv}
\end{frame}

\begin{frame}[fragile]{Global ID Generation (Channel)}
\begin{lstlisting}
func serveMessageIDs(c chan int) int {
    var id int
    for {
        c <- id
        c++
    }
}
\end{lstlisting}
\pause
\begin{lstlisting}
IDSource := make(chan int)
go serveMessageIDs(IDSource)
\end{lstlisting}
\pause
\begin{lstlisting}
client.ID = <-IDSource
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Channels}
\begin{lstlisting}
ch := make(chan byte)
\end{lstlisting}
\begin{onlyenv}<2-3>
\begin{lstlisting}
fmt.Println("Writing to channel")

ch <- 42
\end{lstlisting}
\end{onlyenv}
\begin{onlyenv}<4>
\begin{lstlisting}
fmt.Println("Writing to channel")
\end{lstlisting}
\blocked{ch <- 42\qquad\qquad// DEADLOCKED!}
\end{onlyenv}
\begin{onlyenv}<3->
\begin{lstlisting}
fmt.Println("Reading from channel")
x := <-ch
fmt.Println("Read", x, "from channel")
\end{lstlisting}
\end{onlyenv}
\end{frame}

\begin{frame}[fragile]{Channels}
\begin{lstlisting}
ch := make(chan byte)
go func(c chan byte) {
    x := <-c
    fmt.Println("Read", x, "from channel")
}(ch)

fmt.Println("Writing to channel")
ch <- 42
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Channels}
\begin{lstlisting}
ch := make(chan byte, 1)

fmt.Println("Writing to channel")
ch <- 42

fmt.Println("Reading from channel")
x := <-ch
fmt.Println("Read", x, "from channel")
\end{lstlisting}
\end{frame}


\end{document}
